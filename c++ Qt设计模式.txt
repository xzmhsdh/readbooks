编程风格:
(1).类名称大写字母开头
(2).函数名称以小写字母开头
(3).常量大写，尽可能在类作用域创建枚举值,全局常量和宏大写
(4).类名称应当是一个名词或名词短语
(5).每个函数名称是一个动词或动词短语
(6).if语句，每一个布尔变量应当近似于一个句子:bool isQualified;
(7).数据成员:m_Color,m_Width
(8).静态数据成员:s_Singleton,s_ObjCount。
(9).属性的获取器/设置器
    非布尔型获取器:color() /getColor()。
	布尔型获取器:isChecked() / isValid()。
	设置器: setColor(const Color& newColor)。
	
===========================================================================

c++基础知识点
===========================================================================
1.ostringstream 转 string
  eg:
     ostringstream strbuf;
	 strbuf << "Luckynumber:" << lucky << endl << "pi:" << pi << endl;
	 string strva = strbuf.str();
2.const char * 转 QString
  eg:
     const char *charstr = "this is one...";
     QString str = charstr;
	 
3.std::auto_prt,shared_ptr,QPointer


4.volatile可理解为const的反义,用它标记的对象在任何时候都可以被修改,对编译器
  一个提示:访问它时不进行优化。
  eg:volatile char * vcharptr; //将常规指针声明成volatile内存
     char * volatile vptrchar; //将volatile指针声明成常规内存

5.使用友元的目的:
  1).为了使用工厂方法，需对某个类强制实施某些创建规则.
  2).为了使用全局运算符函数，如operator<<()和operator>>()，此时不希望将运算符
     作为某个类的成员函数，或者没有写入(write-access)类定义的权利.
    eg: friend ostream& operator<<(ostream& os,const Timer& obj);

6.static关键字
  1).static局部变量:首次创建并初始化，程序终止销毁  
  2).static类成员:不会影响对象调用sizeof获得的类对象的大小 
     eg:
	 class Thing{ 
		public:
		 static int showCount(); 
	    private:
		 static int s_Count; //将变量的作用域由全局作用域变成文件作用域
	 };
	 //.cpp
	 int Thing::s_Count = 0; //static成员在类定义之外的文件中被初始化,例外:static const int,其在类定义中被初始化
	 int Thing::showCount(){ return s_Count;}
  3).不在代码块或函数内的static对象，在其相应的对象模块首次加载时会进行初始化，大部分情况在
     启动之后，main()函数运行之前，所以不要使初始化工作依赖于另一个文件中的初始值.
	 
7.类具有指针成员或对象成员时，需要同时编写这个类的复制构造函数和复制赋值构造函数。	
  转换构造函数(只用一个不同类型的实参就可以调用的构造函数):ClassA::ClassA(const ClassB& bObj);
  explicit阻止编译器为了隐式转换而自动使用此转换构造函数。建议对QWidget派生的类使用explicit

8.void Too::foo() const; //非成员函数有一个隐式参数this，指向主对象的指针.声明const则修饰this是一个指向const的指针
  编译器翻译的代码==>_Too_foo_const(const Too* this);
  mutable修饰的Too成员变量，可以在foo()const中被修改其他未被修饰的成员变量则仍然不可修改.

9.(具有多态性的派生(多态函数))this在类的构造函数被初始化，在析构函数被销毁。所以 构造函数和析构函数中不能调用virtual方法. 
  类中包含virtual函数，析构也应该声明为virtual，通常是通过基类指针删除多态对象，导致对析构的间接调用，若不为virutal
  类型，则由编译时绑定调用哪个析构函数，导致派生对象的不完整析构。基类析构声明为virtual，销毁时通过基类指针访问派生对象时，
  会调用合适的派生类析构函数。

10.(抽象基类的派生(多态对象))抽象基类是无法或者不适合实例化的类:1).至少具有一个纯virtual函数 2).没有public构造函数  
  
11.重载、隐藏、重写
   1).重载: foo()具有不同的函数签名
   2).重写: 派生类具有和基类virutal函数相同的函数签名和返回类型
   3).隐藏: 派生类中的成员函数会隐藏基类中与之同名的全部函数。只有派生类函数可以被直接调用，
            基类函数只能显示地用::调用,eg: childobj.BaseClass::hidefunction();

12.	返回指针的成员函数一般声明为private类型.		
    eg:
	class Library:public QList<RefItem*>{
		public:
		  Library(){}
		  ~Library(); //指针容器必须有析构函数
		  QString toString(QString sep="\n")const;
		private:
		  Library(const Library&);
		  Library& operator=(const Library&);
		  RefItem* findRefItem(QString isbn); //不让客户代码操作指针
	};
	Library::~Library(){
		qDeleteAll(*this);
		clear();
	}
	//复制构造和复制赋值运算符从来不会使用，这里提供实现仅仅防止编译器提示警告
	Library::Library(const Library&):QList<RefItem*>(){} //防止没有在构造函数中初始化基类的警告
	Library& operator=(const Library&){return *this;}    //防止赋值运算符没有任何返回值的警告
	RefItem* Library::findRefItem(QString isbn){
		for (int i = 0; i < size(); ++i){ //没调用foreach()宏是因为宏需要复制它所遍历的容器，由于复制构造函数为private,所以只能for
			if (at(i)->getISBN().trimmed() == isbn.trimmed()) return at(i);
		}
	}
	QString Library::toString(QString sep) const {
		QStringList reflst;
		for (int i = 0; i < size(); ++i) //没调用foreach()宏是因为宏需要复制它所遍历的容器，由于复制构造函数为private,所以只能for
			 reflst << at(i)->toString();
		return reflst.join(sep);
	}
	
13.类型转换问题	
   eg:
      enum Types{BOOK,REFERENCEBOOK,TEXTBOOK,DVD,FILM,DATADVD};
	  const QStringList TYPES=(QStringList() << "BOOK" << "REFERENCEBOOK"
	    <<"TEXTBOOK" << "DVD" << "FILM" << "DATADVD");
		
	  void add(Library &lib,QStringList objdata){
		QString type = objdata.first();
		switch(static_cast<Types>(TYPES.indexOf(type))){
		   case BOOK:
		   ...
		}
	  }
 
 
Qt知识点
=================================================================================================================
1.Qt核心模块:core,gui,xml,sql,phonon,webkit
除了core和gui，其他模块都需要在qmake的工程文件中启用:
QT += xml
QT -= gui
QT += sql

2.托管容器:组合类型，容器会管理它所指向的对象。组合关系被销毁时，会完整地销毁自身.
  聚合容器:只对内容提供索引或导航机制的容器。不管理它的对象，只提供访问对象的便利途径,复制聚合容器只复制对象的引用，
		   删除聚合容器，只移除对象的引用，容器底层对象不受影响.
  
3.QObject支持普通c++对象通常没有的特性:
  1).信号和槽
  2).元对象，元属性，元方法
  3).qobject_cast
  
  
  
=================================================================================================================
1.qDebug()
  1).qDebug() << "Here is a debug";
  2).qDebug("Here is one with the number %d in it.",num1);
  
2.QStringList迭代
  eg:
  #include <QStringList>
  #include <QDebug>
  int main(){
	QString winter = "December,January,February";
	QString sprint = "March,April,May";
	QString summer = "June,July,August";
	QString fall = "September,October,November";
	
	QStringList list;
	list << winter;
	list += spring;
	list.append(summer);
	list << fall;
	
	qDebug() <<"The Spring months are:" << list[1];
	QString allmonths = list.join(",");
	qDebug() << allmonths;
	
	QString list2 = allmonths.split(",");
	Q_ASSERT(list2.size() == 12);
	foreach(const QString& str,list){ //Qt foreach循环
	  qDebug() << QString(" [%1] ").arg(str);
	}
	for (QStringList::iterator it = list.begin(); //STL风格迭代
		  it != list.end();++it){
		QString current = *it;
		qDebug() << "[[" << current << "]]";
	}
	QListIterator<QString> itr(list2); //Java1.2风格迭代器
	while (itr.hasNext()){
		QString current = itr.next();
		qDebug() << "{" << current << "}";
	}
	return 0;
  }
  
3.QDir、QFileInfo、QDirIterator
  eg:
  void recurseAddDir(QDir d,bool recursive=true,bool symlinks= false){
	d.setSorting(QDir::Name);
	QDir::Filters  df = QDir::Files | QDir::NoDotAndDotDot;
	if (recursive) df |= Dir::Dirs;
	if (!symlinks) df |= Dir::NoSymLinks;
	QStringList qsl = d.entryList(df,QDir::Name|QDir::DirFirst);
	
	foreach(const QString &entry,qsl){
		QFileInfo finfo(d,entry);
		for (finfo.isDir()){
		  QDir sd(finfo.absoluteFilePath());
		  recurseAddDir(sd);
		} else {
		  if (finfo.completeSuffix() == "map3")
		     addMp3File(finfo.absoluteFilePath());
		}
	}
  }
4. 重载QList的<<操作符
eg:
  //.h
  class Account;
  class Bank{
	public:
	  Bank& operator<<(Account* acct);
	  ~Bank();
	private:
	   QList<Account*> m_Accounts;
  };
  //.cpp
  Bank::~Bank(){
	qDeleteAll(m_Accounts);//<==>qDeleteAll(m_Accounts.begin(),m_Accounts.end()); 对容器中的每一个元素调用delete
	m_Accounts.clear();
  }
  Bank& Bank::operator<<(Account* acct){
	m_Accounts << acct;
	return *this;
  }
  
5.QOjbect
  1).QObject之间基于信号和槽通信,使用QApplication和Qt的事件循环实现了基于事件编程的能力.
  2).QObject没有公有的复制构造和复制赋值函数，不能被复制，也不能通过值传递的方式向函数传递QObject对象.
  3).每个QObject父对象都会管理自己的子对象，调用QOjbect的析构函数会自动销毁该对象的所有子对象。QObject首先会
     调用自己每个子对象的析构函数，每个子对象再调用自己每个子对象的析构函数(递归).
  4).重父化:objA->setParent(objB); objA->setParent(objC);
  5).QOjbect子对象存储在QObjectList中,返回一个指向主对象中全部子对象的指针列表:
     const QObjectList& QObject::children() const;
	 查找子对象:QList<T> parentObj.findChildren<T>(const QString& name = QString())const;
	 eg:
	   QList<Customer*> custlist = parent.findChildren<Customer*>();
	   foreach(const Customer* current,custlist){
			qDebug << current->toString();
	   }
	   
  6).Q_OBJECT宏必须出现在每个QObject派生类定义的头文件中，以便让moc知道要为其生成代码
     若先定义了QObject的派生类，构建了应用程序，后才添加Q_OBJECT宏，需使用qmake更新
	 Makefile文件，执行clean rebuild不能修复此问题.
  7).信号和槽的连接语句:
     bool QObject::connect(senderQObjectPtr,SIGNAL(signalName(argumentList)),
						   receiverQObjectPointer,SLOT(slotName(argumentList)),
						   optionalConnectionType); //最后参数:设置从发射点处同步(阻塞)或非同步(排队)地调用目标槽
     如果多个信号连接到同一个槽上且需要知道是哪一个QObject发射的信号，可在该槽中调用sender()返回指向那个对象的指针
  8).QObject的生命周期
     1).每个QObject在QApplication之后创建，在QApplication销毁前销毁。静态存储区创建的对象将在main()返回之后才被销毁
	    所以不应该定义静态存储类的QObject.
	 2).一般情况，无父对象的QObject应当在栈上创建或定义成另一个类的子对象。有父对象的QObject在堆上创建或由其他对象进行
	    管理。有父对象的在栈上创建可能会被删除两次。
     3).不推荐直接删除QObject,在有事件循环的程序中，最好是利用QObject::deleteLater()来删除QObject,可在应用程序处理事件
	    并在当槽返回之后安排对象的销毁.
	 
	 
6. 带有公有默认构造函数，复制构造，赋值运算符的任何类型都是值类型的。
   让Qt完成引用计数和内存管理：不在堆区创建QList,QString,QHash,QImage,QVariant对象。

7.QTestLib编写的测试代码组织在一个基于单元的框架内。  
  eg: CONFIG += qtestlib
  #include <QtTest>
  class TestAssertEquals:public QObject{
	Q_OBJECT
	private slots:
	  void test();
  };
  void TestAssertEquals::test(){
	qDebug() << "Testing bools";
	bool boolvalue = true;
	QVERIFY(1);
	QVERIFY(true);
	qDebug() << QString("We are in file:%1 Line:%2").arg(__FILE__).arg(__LINE__);
  }  
  
8.窗体布局
  分隔addSpacing(int size)、伸展addStretch(int stretch)、支撑addStrut(int size)
eg1:
  m_name = new QLineEdit;
  m_birthday = new QDateEdit;
  m_birthday->setDisplayFormat("dd/MM/yyyy");
  m_colorButton = new QPushButton(tr("Choose"));
  m_colorButton->setAutoFillBackground(true);
  m_buttons = new QDialogButtonBox(QDialogButtonBox::Ok|QDialogButtonBox::Cancel);
  QVBoxLayout *vbox = new QVBoxLayout;
  QFormLayout *layout = new QFormLayout;
  
  layout->addRow(tr("Name"),m_name);
  layout->addRow(tr("Birthdate"),m_birthday);
  layout->addRow(tr("Favorite Color"),m_colorButton);
  
  vbox->addLayout(layout);
  vbox->addWidget(m_buttons);
  
  Q_ASSERT(vbox->parent() == 0);
  Q_ASSERT(m_birthday->parent() == 0);
  setLayout(vbox); //自动设置自己和子布局中的QWidget父对象为vbox的父对象
  Q_ASSERT(vbox->parent() == this);
  Q_ASSERT(m_birthday->parent() == this);
eg2:
  CardTable::CardTable(QWidget* parent):QWidget(parent)
  {
	QHBoxLayout* row = new QHBoxLayout();
	row->addWidget(new Card("ah"));
	row->addWidget(new Card("qd"));
	row->addWidget(new Card("ks"));
	row->addWidget(new Card("8c"));
	QVBoxLayout* rows = new QVBoxLayout(); //行
	rows->addLayout(row);
	row = new QHBoxLayout();
	row->addWidget(new Card("qs"));
	row->addWidget(new Card("js"));
	row->addWidget(new Card("td"));
	rows->addLayout(row);
	QVBoxLayout* buttons = new QVBoxLayout();
	buttons->addWidget(new QPushButton("Deal"));
	buttons->addWidget(new QPushButton("Shuffle"));
	QHBoxLayout* cols = new QHBoxLayout(); //列
	setLayout(cols);
	cols->addLayout(rows);
	cols->addLayout(buttons);
  }
  
9.Qt处理图片的类  
  1).QImage:用于离屏(off-screen)操作，输入输出操作，可直接访问像素 
  2).QPixmap:用于在屏幕上进行绘制并优化，仅在主线程
  3).QIcon:用于视频内存的缓存，主线程
  4).QPicture:存储绘制的操作而不是实际的位图图片。在使用QPainter的begin()方法，指定在QPicture上绘图
     在end()方法结束绘图，调用QPicture的save()将QPainter的绘图指令存至档案。重播绘图指令调用QPicture
	 的load()方法在指定的绘图装置上绘制QPicture.

10.QTimer
   QTimer::singleShot():在给定的时间间隔后调用一次槽，若倒数间隔设置为0，QTimer会在事件队列中的全部事件
   处理完后就立刻发出timeout()信号.   
	 
11.绘制事件和画图
   QPaintEvent被发送到QWidget上的情况:
   1).窗口由隐藏变为显示
   2).窗件改变了大小或进行重新排布
   3).调用了update()(异步)或repaint()(同步)
   eg:
   void LifeWidget::paintEvent(QPaintEvent* evt){
	  QPainter painter(this); //1.创建一个QPainter
	  if (!m_image.isNull())
	    painter.drawImage(QPoint(0,0),m_image); //2.调用QPainter的API在QWidget上进行绘制
   } 

12.QAction
  1).eg:
     QMenu* menu = new QMenu(tr("&Questions"),this);
     QMainWindow::menuBar()->addMenu(menu);
     menu->addAction(tr("&Ask question"),this,SLOT(askQuestion()),tr("ALT+A"));
	 menu->addAction(tr("A&sk a question"),this,SLOT(askAQuestion()),tr("ALT+D"));
     每次调用QMenu::addAction(text,target,slot,shortchut)函数，都会创建一个未命名的QAction
	 并添加到此QMenu上，然后调用它的基类函数QWidget::addAction(QAction*),这样将新建的QAction添加到
	 用于上下文菜单的QMenu的QAction清单中
  2).QAction、QToolbar、QActionGroup(Lookup Page 235)

13.QSettings (Lookup Page 242) Monostate模式的一种实现。
14.剪贴板和数据传输操作(Lookup Page 244)









=================================================================================================================
设计模式

1.序列化器模式
  eg: QDataStream,QTextStream
    class METADATAEXPORT MetaDataValue{
	 public:
	  friend METADATAEXPORT QTextStream& operator<< (QTextStream& os,
							const MetaDataValue& mdv);
	  friend METADATAEXPORT QTextStream& operator>> (QTextStream& is,
							const MetaDataValue& mdv);
	  friend METADATAEXPORT QDataStream& operator<< (QDataStream& os,
							const MetaDataValue& mdv);
	  friend METADATAEXPORT QDataStream& operator>> (QDataStream& is,
							const MetaDataValue& mdv);
	  friend METADATAEXPORT	bool operator==(const MetaDataValue&,const MetaDataValue&);
   };
   QTextStream& operator<< (QTextStream& os,const MetaDataValue& mdv) //将数据插入到流中
   {
	  QStringList sl;
	  sl << mdv.url.toString() << mdv.trackTitle() << mdv.artist();
	  os << s1.join("\t") << "\n";
	  return os;
   }
   QTextStream& operator>> (QTextStream& is,const MetaDataValue& mdv) //从输入流中提取数据
   {
	  QString line = is.readLine();
	  QStringList fields = line.split("\t");
	  while (fields.size() < 9){
		fields << "";
	  }
	  mdv.m_isNull = false;
	  mdv.setUrl(QUrl::fromUserInput(fields[0]));
	  mdv.setTrackTitle(fields[1]);
	  ...
	  return is;
   }
   QDataStream& operator<< (QDataStream& os,const MetaDataValue& mdv)
   {
	  os << mdv.m_Url << mdv.trackTitle() << mdv.artist();
	  return os;
   }
   QDataStream& operator>> (QDataStream& is,const MetaDataValue& mdv)
   {
      is >> mdv.m_Url >> mdv.m_TrackTitle; 
	  mdv.m_isNull = false;
	  return is;
   }
   void test()
   {
	  QFile textFile("playlist1.tsv");
	  QFile binaryFile("playlist1.bin");
	  QTextStream textStream;
	  QDataStream dataStream;
	  
	  if (textFile.open(QIODevice::ReadOnly)){
		 textStream.setDevice(&textFile);
	  }
	  if (binaryFile.open(QIODevice::WriteOnly)){
		 dataStream.setDevice(&binaryFile);
	  }
	  QList<MetaDataValue> values;
	  while (!textStream.atEnd()){
		 MetaDataValue mdv;
		 textStream >> mdv; //从流中提取一条mdv数据
		 values << mdv;     //将数据插入到QList中
		 dataStream << mdv; //将数据写入到dataStream中
	  }
	  textFile.close();
	  binaryFile.close();
	  textFile.setFileName("playlist2.tsv");//更改打开文件,NoUse
	  if (binaryFile.open(QIODevice::ReadOnly)){
		dataStream.setDevice(&binaryFile);
		for (int i = 0; i < values.size(); ++i;){
			MetaDataValue mdv;
			dataStream >> mdv;
			QCOMPARE(mdv,values[i]); //比较数据是否相等
		}
	  }
   }
   
2.Qt中的观察者模式(Observer pattern):信号和槽  
  当任意数据模型对象发生状态改变时，需要一种间接的方式来提醒观察者，
  观察者是一些正在监听并响应状态变化事件的对象。使用这种消息传递机制
  的设计模式称为观察者模式或发布-订阅模式 
  共同特征:1).允许实体观察者类和实体主体类之间解耦
		   2).支持广播风格(一对多)的通信
		   3).所采用的从主体向观察者发送信息得机制完全由主体的基类给定
  
3.命令模式
  Qt实现命令模式:
  1).创建一些命令并在适当的容器内对它们进行排队
  2).把QUndoCommand放到QUndoStack上即可得到执行
  3).若需同时执行各个命令，可从QRunnable派生它们，使用QtConcurrent::Run()在线程池中对它们进行调度.
  4).或许会把一些命令序列化到文件并在随后再次对它们进行调用，以用来实现批处理或分布式执行。
  eg:图片像素操作
  void AdjustColors::adjust(dobule radj,dobule gadj,dobule badj)
  {
	int h(m_Image.height()),w(m_Image.width());
	int r,g,b;
	QRgb oldpix,newpix;
	m_Saved = m_Image.copy(QRect());
	for(int y = 0; y < h;++y){
		for(int x = 0;x < w; ++x){
			oldpix = m_Image.pixel(x,y);
			r = qRed(oldpix)*radj;
			g = qGreen(oldpix)*gadj;
			b = qBlue(oldpix)*badj;
			newpix = qRgb(r,g,b);
			m_Image.setPixel(x,y,newpix);
		}
	}
  }
  void AdjustColors::redo(){
	qDebug() << "AdjustColors::redo()";
	adjust(m_RedAdj,m_GreenAdj,m_BlueAdj);
  }
  void AdjustColors::undo(){
	qDebug() << "AdjustColors::undo()";
	m_Image = m_Saved.copy(QRect());
  }
  
  
  
  
  
  
  
  